scriptencoding utf-8

"-----------------------------------------------------------------------
" Vim settings file for Greg Fitzgerald 
"
" Most recent update: Wed 30 Apr 2008 08:45:48 PM EDT
"
"-----------------------------------------------------------------------

set nowrap                      " Turn off word-wrapping
set nobackup                    " Turn backups off
set noswapfile
set writebackup                 " Write backups
set sw=4
set sts=4
set ts=4
set expandtab  " expand tabs to spaces
set hlsearch
set backupext=.bak              " Append `.bak' to backups
set backupdir=~/.backups/       " Directory to save backups in
set linebreak                   " For when we have wrapping on
"set nonumber                   " Show line numbers
set number
set ruler                       " Turn on ruler
set bs=2                        " Backspacing over everything
set hls                         " Highlight search patterns
set ignorecase                  " Case-insensitive searches
set autoindent                          " Auto-indenting
set shm+=Im                     " No start up message
set si                          " Disable 'smart'-indenting
set sm                          " Show bracket match
set report=0                    " Report any number of line changes
set mat=1                       " Bracket match highlight time
set dir=~/.tmp/vim/             " Temp dir
set clipboard=unnamed           " Universal clipboard
set ww+=<,>,[,]                 " Movement keys (for wrapping)
set hidden                      " Allow unsaved, hidden buffers
set background=dark             " Light colors
set laststatus=2                " Always display status line
set viminfo='1000,f1,:1000,/1000
set showcmd
set history=500
"set statusline=%<%F%m%=\ %y\ [Lines:\ %L]\ [Col:\ %v]\ [Char:\ %c]\ [%P]
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
set fileformat=unix             " Always UNIX line endings
set tabstop=4                   " 8-space tabs
set formatoptions=              " Clear any stupid formatting options
set selectmode=key              " Typing in virtual mode deletes hilighted text
set wildmode=list:longest       " Display list of matching files for completion
set wildignore=*.o,*.class,*~
"set is                         " Show match for partly typed search
"set sc                         " Show current command in status
set noeol                       " Don't require end-of-line
set report=0                    " Report any number of line changes
set breakat=\ \ !@*-+;:,.?      " Characters to break text for wrapping
set showbreak=\ \ \ \ \ \ \ \   " Tab for wrapping
set scrolljump=15               " Number of lines to jump when cursor reaches term bottom
set sidescroll=15               " Same thing for horizontal
set smartcase                   " Capital letters override ignorecase
set vb t_vb=                    " No bells
set nocompatible
set encoding=utf-8
set wildmenu
set ruler
set smartindent
set smarttab
set cursorline
set lbr
set enc=utf-8

highlight RedundantSpaces ctermbg=red guibg=red
match     RedundantSpaces /\s\+$\| \+\ze\t/

if (version >= 700)
        set completeopt=longest
        map :e<Space> :tabe<Space>
        map :bn :tabn
        map :bp :tabp
        set showtabline=2
        set tabline=%!MyTabLine()
        set nofen               " Disable folds

        function MyTabLabel(n)
                let buflist = tabpagebuflist(a:n)
                let winnr = tabpagewinnr(a:n)
                let bufname = bufname(buflist[winnr - 1])

                if !strlen(bufname)
                        let bufname = '(nil)'
                endif

                let label = ''
                " Add '+' if one of the buffers in the tab page is modified
                let bufnr = 0
                while bufnr < len(buflist)
                        if getbufvar(buflist[bufnr], "&modified")
                                let label = '+'
                                break
                        endif
                        let bufnr = bufnr + 1
                endwhile
                if !strlen(label)
                        let label = ' '
                endif
                let label .= bufname
                return label
        endfunction

        function MyTabLine()
                let s = ''
                let i = 1
                while i <= tabpagenr('$')
                        " select the highlighting
                        if i == tabpagenr()
                                let s .= '%#TabLineSel#'
                        else
                                let s .= '%#TabLine#'
                        endif

                        " set the tab page number (for mouse clicks)
                        let s .= '%' . i . 'T'

                        " the label is made by MyTabLabel()
                        let s .= ' %{MyTabLabel(' . i . ')} '

                        let i = i + 1
                endwhile

                " after the last tab fill with TabLineFill and reset tab page nr
                let s .= '%#TabLineFill#%T'
                return s
        endfunction
endif

if version >= 700
  if has('insert_expand')
    set completeopt=menuone
  endif
endif

" Update .*rc header
    fun! <SID>UpdateRcHeader()
        let l:c=col(".")
        let l:l=line(".")
        silent 1,10s-\(Most recent update:\).*-\="Most recent update: ".strftime("%c")-e
        call cursor(l:l, l:c)
    endfun

let loaded_matchparen=1

if (has("gui_running"))
    set guifont=Terminus\ 14
        set mousem=popup        " Nice pop-up
        "set km=startsel,stopsel        " Use keys to select text
        set selection=exclusive " Allow one char past EOL
        set ttymouse=xterm2     " Terminal type for mouse code recognition
endif

" Typos
map             :W :w
map             :WQ :wq
map             :wQ :wq
map             :Q :q
map             0 <Nop>
nmap <C-N> :tabn<CR>
nmap <C-P> :tabp<CR>
noremap <silent> <C-O> :FuzzyFinderFile<CR> 
noremap <silent> <F8> :FuzzyFinderMruFile<CR>
noremap <silent> <F7> :FuzzyFinderFile<CR>
noremap <silent> <F9> :NERDTreeToggle<CR>

" Refreshing the screen
map             <C-l>                :redraw<CR>
imap    <C-l>           <Esc>:redraw<CR>a

if has("autocmd")
    
    " Update header in .vimrc and .bashrc before saving
    autocmd BufWritePre *vimrc  :call <SID>UpdateRcHeader()
    autocmd BufWritePre *zshrc :call <SID>UpdateRcHeader()
   
    " For svn-commit, don't create backups
    autocmd BufRead svn-commit.tmp :setlocal nobackup
    autocmd FileType perl        map <F1>       :!perl -W  %<CR>
        autocmd FileType perl   imap <F1>  <Esc>:!perl -W  %<CR>
        autocmd FileType perl    map <F2>       :!perl -Wc %<CR>
        autocmd FileType perl   imap <F2>  <Esc>:!perl -Wc %<CR>
        
    autocmd FileType ruby setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
    autocmd FileType html,xhtml,xml,htmldjango,htmljinja,eruby,mako setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
    autocmd FileType css setlocal expandtab shiftwidth=4 tabstop=4 softtabstop=4
    autocmd FileType javascript setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2


        autocmd FileType xml     map <F2>       :!xmllint --valid --postvalid -o /dev/null %<CR>
        autocmd FileType xml    imap <F2>  <Esc>:!xmllint --valid --postvalid -o /dev/null %<CR>

        autocmd FileType xslt    map <F2>       :!xsltproc -o /dev/null %<CR>
        autocmd FileType xslt   imap <F2>  <Esc>:!xsltproc -o /dev/null %<CR>

        autocmd FileType xslt,xml,xhtml,html set ts=2
    autocmd FileType php set ts=4 complete+=k
    autocmd FileType rails,haml,ruby,eruby,yaml set ai sw=2 sts=2 ts=8 et

        
    autocmd BufReadPost,BufNewFile,BufRead rsnapshot.conf set noet

        " When editing a file, jump to the last cursor position
        autocmd BufReadPost *
    \   if line("'\"") > 0 && line ("'\"") <= line("$")
    \   |       exe "normal g'\""
    \   | endif
        
    autocmd BufReadPost * set fo=

    autocmd BufNewFile,BufRead /tmp/mutt* setf mail
    au BufRead,BufNewFile .followup,.article,.letter,/tmp/pico*,nn.*,snd.*,/tmp/mutt* :set ft=mail
    au BufRead,BufNewFile .followup,.article,.letter,/tmp/pico*,nn.*,snd.*,~/.tmp/mutt/mutt* :set ft=mail 
    au! BufRead,BufNewFile *.haml         setfiletype haml
    au! BufRead,BufNewFile *.sass         setfiletype sass
        autocmd BufNewFile,BufRead *.inc
\                 if getline(1) =~ 'php'
\               |       setf php
\               | else
\               |       setf perl
\               | endif

        autocmd BufNewFile *.pl set noai | execute "normal a
\#!/usr/bin/perl -W\<CR>
\# $Id\$\<CR>
\\<CR>
\use strict;\<CR>
\use warnings;\<CR>
\\<CR>" | set ai
        
    autocmd BufNewFile *.htm,*.html     set noai | execute "normal a
\<!DOCTYPE html PUBLIC \"-//W3C//XHTML 1.0 Transitional//EN\">\<CR>
\\<CR>
\<html lang=\"en-US\" xml:lang=\"en-US\" xmlns=\"http://www.w3.org/1999/XHTML\">\<CR>
\       <head>\<CR>
\               <title></title>\<CR>
\               <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" />\<CR>
\       </head>\<CR>
\       <body>\<CR>
\       </body>\<CR>
\</html>" | set ai
endif

" Removes unneccessary whitespace
function StripWhite()
        %s/[ \t]\+$//ge
        %s!^\( \+\)\t!\=StrRepeat("\t", 1 + strlen(submatch(1)) / 8)!ge
endfunction

" Set some colors
if &term == 'rxvt-256color'
    set term=rxvt-256color
    set t_Co=256 " Let ViM know we have a 256 color capible terminal
    "colorscheme railscasts
    colorscheme ir_black
    "colorscheme darkspectrum
    "colorscheme northland
else
    colorscheme jammy
endif
 
if has('title') && (has('gui_running') || &title)
    set titlestring=
    set titlestring+=%f\                     " file name
    set titlestring+=%h%m%r%w                " flags
    set titlestring+=\ -\ %{v:progname}      " program name
    colorscheme ir_black 
endif

" Extra terminal things
if (&term =~ "xterm") && (&termencoding == "")
    set termencoding=utf-8
endif

if &term =~ "xterm"
    if has('title')
        set title
    endif
    if exists('&t_SI')
        let &t_SI = "\<Esc>]12;lightgoldenrod\x7"
        let &t_EI = "\<Esc>]12;grey80\x7"
    endif
endi

" If possible, try to use a narrow number column.
if v:version >= 700
    try
        setlocal numberwidth=3
    catch
    endtry
endif

