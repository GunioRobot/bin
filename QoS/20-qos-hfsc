#!/bin/sh

# qos-script v1.05 (hfsc)

## Please modify user configuration in /etc/qos.conf
## To start QoS without reboot, use "ifdown wan && ifup wan"

# User configuration
[ -f /etc/qos.conf ] && . /etc/qos.conf

# If no interface defined, use WAN interface
[ "$QOS_IF" ] || QOS_IF=$(nvram get wan_ifname)

# Find out interface of hotplug event
HOTPLUG_IF=$(nvram get ${INTERFACE}_ifname)

# Script can be activated by hotplug event on qos interface or passing "qosstart" in $INTERFACE
if [ "$ACTION" = "ifup" -a \( "$HOTPLUG_IF" = "$QOS_IF" -o "$INTERFACE" = "qosstart" \) ]; then

  # Length of burst buffers in ms (must be larger than kernel jiffy of 10ms)
  DBURST_D=10
  DBURST_U=10

  MTU=1600

  # The following packages are required for the modules:
  # kmod-sched
  # kmod-ipt-conntrack
  # iptables-mod-conntrack
  # kmod-ipt-ipopt
  # iptables-mod-ipopt
  # kmod-ipt-extra
  # iptables-mod-extra
  # ip
  # kmod-imq
  # iptables-mod-imq
  # kmod-ipt-filter
  # iptables-mod-filter

  insmod cls_fw >&- 2>&-
  insmod sch_hfsc >&- 2>&-
  insmod sch_sfq >&- 2>&-
  insmod ipt_CONNMARK >&- 2>&-
  insmod ipt_length >&- 2>&-
  insmod imq numdevs=1 >&- 2>&-
  insmod ipt_IMQ >&- 2>&-
  insmod ipt_ipp2p >&- 2>&-
  insmod ipt_layer7 >&- 2>&-
  insmod ipt_tos >&- 2>&-
  insmod ipt_TOS >&- 2>&-
  insmod ipt_dscp >&- 2>&-
  insmod ipt_DSCP >&- 2>&-
  insmod sch_red >&- 2>&-

  # To enable logging (requires iptables-mod-extra package)
  [ "$DEBUG" -eq 1 ] && insmod ipt_LOG >&- 2>&-

  iptables -t mangle -F
  iptables -t mangle -X

  # Set up the InterMediate Queuing device (IMQ)
  ip link set imq0 up

  # Remove queuing disciplines from all interfaces
  sed -n 's/ *\(.*\):.*/\1/p' /proc/net/dev | while read INTERFACE; do
    tc qdisc del dev $INTERFACE root >&- 2>&-
  done

  [ $UPLOAD -ne 0 ] && {
    # Calculate MTU duration
    DMTU_U=$((8*$MTU/$UPLOAD))

    # Make sure burst duration is at least MTU
    [ $DBURST_U -lt $((1*$DMTU_U)) ] && DBURST_U=$((1*$DMTU_U))

    # Attach egress queuing discipline to QoS interface
    tc qdisc add dev $QOS_IF root handle 1: hfsc default 40
    # For the root qdisc, only ul is relevant, since there is no link sharing, and rt only applies to leaf qdiscs
    tc class add dev $QOS_IF parent 1: classid 1:1 hfsc sc rate ${UPLOAD}kbit ul rate ${UPLOAD}kbit
    tc class add dev $QOS_IF parent 1:1 classid 1:10 hfsc sc m1 $(($UPLOAD*10/10))kbit d ${DBURST_U}ms m2 $(($UPLOAD*5/10))kbit
    tc class add dev $QOS_IF parent 1:1 classid 1:20 hfsc sc m1 $(($UPLOAD*8/10))kbit d ${DBURST_U}ms m2 $(($UPLOAD*2/10))kbit
    tc class add dev $QOS_IF parent 1:1 classid 1:30 hfsc sc m1 $(($UPLOAD*5/10))kbit d ${DBURST_U}ms m2 $(($UPLOAD*2/10))kbit
    tc class add dev $QOS_IF parent 1:1 classid 1:40 hfsc sc m1 $(($UPLOAD*0/10))kbit d ${DBURST_U}ms m2 $(($UPLOAD*1/10))kbit

    tc qdisc add dev $QOS_IF parent 1:10 sfq quantum $MTU perturb 10
    tc qdisc add dev $QOS_IF parent 1:20 sfq quantum $MTU perturb 10
    tc qdisc add dev $QOS_IF parent 1:30 sfq quantum $MTU perturb 10
    tc qdisc add dev $QOS_IF parent 1:40 sfq quantum $MTU perturb 10

    tc filter add dev $QOS_IF parent 1: prio 1 protocol ip handle 1 fw flowid 1:10
    tc filter add dev $QOS_IF parent 1: prio 2 protocol ip handle 2 fw flowid 1:20
    tc filter add dev $QOS_IF parent 1: prio 3 protocol ip handle 3 fw flowid 1:30
    tc filter add dev $QOS_IF parent 1: prio 4 protocol ip handle 4 fw flowid 1:40
  }

  [ $DOWNLOAD -ne 0 ] && {
    # Calculate MTU duration
    DMTU_D=$((8*$MTU/$DOWNLOAD))

    # Make sure burst duration is at least MTU
    [ $DBURST_D -lt $((1*$DMTU_D)) ] && DBURST_D=$((1*$DMTU_D))

    # Attach ingress queuing discipline to IMQ interface
    tc qdisc add dev imq0 root handle 1: hfsc default 40
    # For the root qdisc, only ul is relevant, since there is no link sharing, and rt only applies to leaf qdiscs
    tc class add dev imq0 parent 1: classid 1:1 hfsc sc rate ${DOWNLOAD}kbit ul rate ${DOWNLOAD}kbit
    tc class add dev imq0 parent 1:1 classid 1:10 hfsc sc m1 $(($DOWNLOAD*10/10))kbit d ${DBURST_D}ms m2 $(($DOWNLOAD*5/10))kbit
    tc class add dev imq0 parent 1:1 classid 1:20 hfsc sc m1 $(($DOWNLOAD*8/10))kbit d ${DBURST_D}ms m2 $(($DOWNLOAD*2/10))kbit
    tc class add dev imq0 parent 1:1 classid 1:30 hfsc sc m1 $(($DOWNLOAD*5/10))kbit d ${DBURST_D}ms m2 $(($DOWNLOAD*2/10))kbit
    tc class add dev imq0 parent 1:1 classid 1:40 hfsc sc m1 $(($DOWNLOAD*0/10))kbit d ${DBURST_D}ms m2 $(($DOWNLOAD*1/10))kbit ul rate $(($DOWNLOAD*3/4))kbit

    tc qdisc add dev imq0 parent 1:10 red limit $((40*$MTU)) min $((5*$MTU)) max $((20*$MTU)) avpkt $(($MTU*6/10)) burst 16 probability 0.015
    tc qdisc add dev imq0 parent 1:20 red limit $((40*$MTU)) min $((5*$MTU)) max $((20*$MTU)) avpkt $(($MTU*6/10)) burst 16 probability 0.015
    tc qdisc add dev imq0 parent 1:30 red limit $((40*$MTU)) min $((5*$MTU)) max $((20*$MTU)) avpkt $(($MTU*6/10)) burst 16 probability 0.015
    tc qdisc add dev imq0 parent 1:40 red limit $((40*$MTU)) min $((5*$MTU)) max $((20*$MTU)) avpkt $(($MTU*6/10)) burst 16 probability 0.015

    tc filter add dev imq0 parent 1: prio 1 protocol ip handle 1 fw flowid 1:10
    tc filter add dev imq0 parent 1: prio 2 protocol ip handle 2 fw flowid 1:20
    tc filter add dev imq0 parent 1: prio 3 protocol ip handle 3 fw flowid 1:30
    tc filter add dev imq0 parent 1: prio 4 protocol ip handle 4 fw flowid 1:40
  }

  iptables -t mangle -N mark_chain
  iptables -t mangle -N egress_chain
  iptables -t mangle -N ingress_chain

  # Set up egress marking chain
  iptables -t mangle -A POSTROUTING -o $QOS_IF -j egress_chain

  # Mark ingress in FORWARD and INPUT chains to make sure any DNAT (virt. server) is taken into account
  # Mark ingress in FORWARD chain for LAN and send through the IMQ device
  iptables -t mangle -A FORWARD -i $QOS_IF -j ingress_chain
  iptables -t mangle -A FORWARD -i $QOS_IF -j IMQ --todev 0

  # Mark ingress in INPUT chain for this router and send through the IMQ device
  iptables -t mangle -A INPUT -i $QOS_IF -j ingress_chain
  iptables -t mangle -A INPUT -i $QOS_IF -j IMQ --todev 0

  #################################### FUNCTION DEFINITIONS ############################################
  mark_addr_in()
    {
     # Set up ingress rules based on ip_address[:port[:range]]
     # $1 is a list of ip:port elements
     # $2 is the priority

     for ADDR in $1; do
       IP_PART=`echo $ADDR | sed -n 's/\([^:]*\):.*/\1/p'`
       if [ "$IP_PART" ]; then
         PORT_PART=`echo $ADDR | sed -n 's/[^:]*:\(.*\)/\1/p'`
         iptables -t mangle -A ingress_chain -d $IP_PART -p tcp --dport $PORT_PART -j MARK --set-mark $2
         iptables -t mangle -A ingress_chain -d $IP_PART -p udp --dport $PORT_PART -j MARK --set-mark $2
       else
         iptables -t mangle -A ingress_chain -d $ADDR -j MARK --set-mark $2
       fi
     done
    }

  mark_addr_out()
    {
     # Set up egress rules based on ip_address[:port[:range]]
     # $1 is a list of ip:port elements
     # $2 is the priority

     for ADDR in $1; do
       IP_PART=`echo $ADDR | sed -n 's/\([^:]*\):.*/\1/p'`
       if [ "$IP_PART" ]; then
         PORT_PART=`echo $ADDR | sed -n 's/[^:]*:\(.*\)/\1/p'`
         iptables -t mangle -A egress_chain -s $IP_PART -p tcp --dport $PORT_PART -j MARK --set-mark $2
         iptables -t mangle -A egress_chain -s $IP_PART -p udp --dport $PORT_PART -j MARK --set-mark $2
       else
         iptables -t mangle -A egress_chain -s $ADDR -j MARK --set-mark $2
       fi
     done
    }
  ######################################################################################################

  ###################################### MARK CHAIN ####################################################
  # Restore any saved connection mark if not already marked
  iptables -t mangle -A mark_chain -m mark --mark 0 -j CONNMARK --restore-mark

  # Mark expr packets based on port numbers and protocol
  for PORT in $UDP_EXPR; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p udp --dport $PORT -j MARK --set-mark 1
  done
  for PORT in $TCP_EXPR; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p tcp --dport $PORT -j MARK --set-mark 1
  done

  # Mark prio packets based on port numbers and protocol
  for PORT in $UDP_PRIO; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p udp --dport $PORT -j MARK --set-mark 2
  done
  for PORT in $TCP_PRIO; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p tcp --dport $PORT -j MARK --set-mark 2
  done

  # Mark bulk packets based on port numbers and protocol
  for PORT in $UDP_BULK; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p udp --dport $PORT -j MARK --set-mark 4
  done
  for PORT in $TCP_BULK; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -p tcp --dport $PORT -j MARK --set-mark 4
  done

  # Mark expr packets based on ipp2p match
  ALL_PROTOS=""
  for PROTO in $IPP2P_EXPR; do
    ALL_PROTOS="${ALL_PROTOS}--$PROTO "
  done
  [ "$ALL_PROTOS" ] && iptables -t mangle -A mark_chain -m mark --mark 0 -m ipp2p $ALL_PROTOS -j MARK --set-mark 1

  # Mark prio packets based on ipp2p match
  ALL_PROTOS=""
  for PROTO in $IPP2P_PRIO; do
    ALL_PROTOS="${ALL_PROTOS}--$PROTO "
  done
  [ "$ALL_PROTOS" ] && iptables -t mangle -A mark_chain -m mark --mark 0 -m ipp2p $ALL_PROTOS -j MARK --set-mark 2

  # Mark bulk packets based on ipp2p match
  ALL_PROTOS=""
  for PROTO in $IPP2P_BULK; do
    ALL_PROTOS="${ALL_PROTOS}--$PROTO "
  done
  [ "$ALL_PROTOS" ] && iptables -t mangle -A mark_chain -m mark --mark 0 -m ipp2p $ALL_PROTOS -j MARK --set-mark 4

  # Mark expr packets based on layer7 match
  for PROTO in $L7_EXPR; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -m layer7 --l7proto $PROTO -j MARK --set-mark 1
  done

  # Mark prio packets based on layer7 match
  for PROTO in $L7_PRIO; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -m layer7 --l7proto $PROTO -j MARK --set-mark 2
  done

  # Mark bulk packets based on layer7 match
  for PROTO in $L7_BULK; do
    iptables -t mangle -A mark_chain -m mark --mark 0 -m layer7 --l7proto $PROTO -j MARK --set-mark 4
  done

  # Default is normal priority (to make sure every packet on WAN interface gets marked)
  iptables -t mangle -A mark_chain -m mark --mark 0 -j MARK --set-mark 3

  # Save mark onto connection
  iptables -t mangle -A mark_chain -j CONNMARK --save-mark

  # ICMP gets high priority (impress friends)
  iptables -t mangle -A mark_chain -p icmp -j MARK --set-mark 1
  iptables -t mangle -A mark_chain -p ipv6-icmp -j MARK --set-mark 1

  # Small UDP packets (most likely games) get high priority
  [ "$UDP_LENGTH" -gt 0 ] && iptables -t mangle -A mark_chain -p udp -m length --length :$UDP_LENGTH -j MARK --set-mark 1
  ######################################################################################################

  ###################################### INGRESS CHAIN #################################################
  # Mark bulk packets based on destination LAN ip address and port number
  mark_addr_in "$IP_BULK" 4

  # Mark prio packets based on destination LAN ip address and port number
  mark_addr_in "$IP_PRIO" 2

  # Mark expr packets based on destination LAN ip address and port number
  mark_addr_in "$IP_EXPR" 1

  # Call mark_chain
  iptables -t mangle -A ingress_chain -j mark_chain
  ######################################################################################################
  
  ######################################## EGRESS CHAIN ################################################
  # Mark bulk packets based on tos match (egress only)
  for PROTO in $TOS_BULK; do
    iptables -t mangle -A egress_chain -m tos --tos $PROTO -j MARK --set-mark 4
  done

  # Mark prio packets based on tos match (egress only)
  for PROTO in $TOS_PRIO; do
    iptables -t mangle -A egress_chain -m tos --tos $PROTO -j MARK --set-mark 2
  done

  # Mark expr packets based on tos match (egress only)
  for PROTO in $TOS_EXPR; do
    iptables -t mangle -A egress_chain -m tos --tos $PROTO -j MARK --set-mark 1
  done

  # Mark bulk packets based on dscp match (egress only)
  for PROTO in $DSCP_BULK; do
    iptables -t mangle -A egress_chain -m dscp --dscp $PROTO -j MARK --set-mark 4
  done

  # Mark prio packets based on dscp match (egress only)
  for PROTO in $DSCP_PRIO; do
    iptables -t mangle -A egress_chain -m dscp --dscp $PROTO -j MARK --set-mark 2
  done

  # Mark expr packets based on dscp match (egress only)
  for PROTO in $DSCP_EXPR; do
    iptables -t mangle -A egress_chain -m dscp --dscp $PROTO -j MARK --set-mark 1
  done

  # Mark bulk packets based on source LAN ip address and port number
  mark_addr_out "$IP_BULK" 4

  # Mark prio packets based on source LAN ip address and port number
  mark_addr_out "$IP_PRIO" 2

  # Mark expr packets based on source LAN ip address and port number
  mark_addr_out "$IP_EXPR" 1

  # Call mark_chain
  iptables -t mangle -A egress_chain -j mark_chain

  # Make sure ACK packets get priority (to avoid upload speed limiting our download speed)
  iptables -t mangle -A egress_chain -p tcp -m length --length :128 --tcp-flags SYN,RST,ACK ACK -j MARK --set-mark 1
  ######################################################################################################

  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 0 -j LOG --log-prefix egress_0::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 0 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 1 -j LOG --log-prefix egress_1::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 1 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 2 -j LOG --log-prefix egress_2::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 2 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 3 -j LOG --log-prefix egress_3::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 3 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 4 -j LOG --log-prefix egress_4::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -m mark --mark 4 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A egress_chain -j LOG --log-prefix egress_other::

  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 0 -j LOG --log-prefix ingress_0::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 0 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 1 -j LOG --log-prefix ingress_1::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 1 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 2 -j LOG --log-prefix ingress_2::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 2 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 3 -j LOG --log-prefix ingress_3::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 3 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 4 -j LOG --log-prefix ingress_4::
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -m mark --mark 4 -j ACCEPT
  [ "$DEBUG" -eq 1 ] && iptables -t mangle -A ingress_chain -j LOG --log-prefix ingress_other::

fi
exit 0
